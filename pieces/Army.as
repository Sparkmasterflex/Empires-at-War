package pieces {  import armyBase;    import com.greensock.*;  import com.greensock.easing.*;    import common.ImgLoader;  import common.Label;    import dispatch.AddListenerEvent;    import flash.display.MovieClip;  import flash.events.*;    import static_return.FindAndTestSquare;  import static_return.GameConstants;  import static_return.GetDirection;  import static_return.UnitsStartNumbers;
    public class Army extends GamePiece {    /*--------Classes Added------------*/    public var army:armyBase;	public var lbl:Label;  		public function Army(emp, troops, num) {	  super();	  army = new armyBase();	  scaleX = .85;	  scaleY = .85;	  addChild(army);	  setAttributes(emp, troops, num);	  addEventListener(MouseEvent.CLICK, animateSelect);  	}		private function setAttributes(emp, troops, num) {	  attr = new Object();	  attr['pieceType'] = "army";	  named("army_" + num + "_" + emp);	  setEmpire(emp);	  facing(true);	  moves(5);	  addUnits(troops); 	}		public function facing(left=null) {	  if(left != null) attr['facing'] = left;	  return attr['facing'];	}		public function moves(num=null) {	  if(num) attr['moves'] = num;	  return attr['moves'];	}		public function units() {	  return attr['units'];	}		private function setEmpire(e) {	  switch(e) {		case 'Gaul':		  army.armyIsGaul();		  break;		case 'Rome':		  army.armyIsRoman();		  break;		default:		  trace('none');	  }	}		public function addUnits(troops:*) {	  if(troops is Array) {		newUnits(troops, findLastUnitKey(attr['units']));	  } else {		var last = findLastUnitKey(attr['units']);	    for(var j:String in troops) {		  last++;		  attr['units'][last + '_unit'] = troops[j];		}	  }	}		private function newUnits(troops, last) {	  if(attr['units'] == null) attr['units'] = new Object();	  for(var i:uint=0; i<troops.length; i++) {		attr['units'][(i + last) + '_unit'] = [troops[i], UnitsStartNumbers.ret(troops[i], attr['empire'])];	  }	}		public function findLastUnitKey(obj):Number {	  var arr = new Array();	  if(obj == null) {		return 0;	  } else {		for(var j:String in obj) arr.push(j.replace(/_.*$/, ''));		arr.sort().reverse();		return arr[0];	  }	}		public function animateSelect(event:MouseEvent) {	  var frame = '';	  if(isSelected) {		frame = 'select-ed'		dispatchEvent(new AddListenerEvent(AddListenerEvent.EVENT, this, true));	  } else {		frame = 'unselect-ed';		dispatchEvent(new AddListenerEvent(AddListenerEvent.EVENT, this, false));	  }	  army.gotoAndPlay(frame);	}		public function pieceMoveKeyBoard(event:KeyboardEvent) {	  var key = event.keyCode,		  currSq = square(),	  	  toSq = FindAndTestSquare.ret(key, this),	  	  stage = this.parent,		  section = stage.sGridArr[toSq.split('_')[0]];	  if(directionKeys.indexOf(key) >= 0) {	    dispatchEvent(new AddListenerEvent(AddListenerEvent.EVENT, this, false));	    var toSquare = section.getChildByName(toSq);	    if(toSquare.gridInfo['land'] === true && moves() > 0) {		  changeDirection(currSq, toSquare);		  army.gotoAndPlay('walk');		  TweenLite.to(this, .5,		    { x:(toSquare.gridInfo.posX), y: (toSquare.gridInfo.posY), onComplete: stopWalk, onCompleteParams: [toSquare]});   	    } else {	      dispatchEvent(new AddListenerEvent(AddListenerEvent.EVENT, this, true));	    }	  }  	}		public function stopWalk(sq) {	  army.gotoAndPlay('stand');	  square(sq);	  attr['moves']--;	  lbl.text = moves();	  dispatchEvent(new AddListenerEvent(AddListenerEvent.EVENT, this, true));	}		private function changeDirection(sq, newSq) {	  var left = GetDirection.ret(sq, newSq);	  if(facing() != left) {		left ? this.scaleX = 0.85 : this.scaleX = -0.85;		facing(left);	  }	}  }}