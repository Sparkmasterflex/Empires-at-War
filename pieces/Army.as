package pieces {  import armyBase;    import com.greensock.*;  import com.greensock.easing.*;    import common.ImgLoader;  import common.Label;    import dispatch.AddListenerEvent;  import dispatch.PopupEvent;    import empires.Empire;    import flash.display.MovieClip;  import flash.events.*;  import flash.utils.*;  import flash.external.ExternalInterface;  import com.demonsters.debugger.MonsterDebugger;    import pieces.agents.Settler;    import static_return.FindAndTestSquare;  import static_return.GameConstants;  import static_return.GetDirection;  import static_return.UnitsStartNumbers;    public class Army extends GamePiece {    /*--------Classes Added------------*/    public var lbl:Label;    private var interval;        /*-------- Numbers ------------*/    public var u_length:uint;    	  	public function Army(emp, num, attributes) {      super(emp);      MonsterDebugger.initialize(this);  	  this_empire = emp;  	  game_piece = new armyBase();      u_length = 0;  	  scaleX = .85;  	  scaleY = .85;  	  addChild(game_piece);      this_empire.pieceArray.push(this);      this_empire.armyArray.push(this);      if(attributes.id != null) this_id(attributes.id);      empire_id(emp.attr['id']);  	  setAttributes(num, attributes);  	  addEventListener(MouseEvent.CLICK, animateSelect);    }    private function setAttributes(num, a=null) {      attr['pieceType'] = "army";      setEmpire();      named("army_" + num + "_" + empire()[0]);      // arrays passed are already AS classes      if(!a.instant_save && !a.id) {        units(a.units);        if(a.agents) agents(a.agents);      } else {        // build units from strings        var unit_arr = a.id ? parseUnitsString(a.units) : a.units,            agent_arr = a.id ? null : a.agents;        units(build_units(unit_arr));        if(agent_arr) agents(agent_arr);      }      // position and set direction      if(a.square) square(a.square);      facing(true);      moves(5);      if(a.instant_save) // on game load/reload if not in DB        interval = setInterval(test_for_save, 100, unit_arr.length);      else        displayTotalMenBar();    }    private function test_for_save(len) {      if(u_length >= len) {        displayTotalMenBar();        ExternalInterface.call('savePiece', createJSON());        clearInterval(interval);      }    }  	private function setEmpire() {      empire(this_empire.empire());  	  switch(empire()[0]) {    		case GameConstants.GAUL:    		  game_piece.armyIsGaul();    		  break;    		case GameConstants.ROME:    		  game_piece.armyIsRome();    		  break;    		default:    		  trace('none');    	  }  	}        public override function createJSON() {      var json = {        id: this_id(),        pieceType: 20,        empire_id: empire_id(),        name: named(),        square: square().name,        moves: moves(),        units: ""      }      units().forEach(function(unit) { json['units'] += unit.type() + "," + unit.men() + "||"; });      if(agents()) agents().forEach(function(agent) { json['agents'] += agent.type + "||"; });            return json;    }      	public function animateSelect(event:MouseEvent) {  	  var frame = '';  	  if(isSelected) {    		frame = 'select-ed'    		dispatchEvent(new AddListenerEvent(AddListenerEvent.EVENT, this, true));  	  } else {    		frame = 'unselect-ed';    		dispatchEvent(new AddListenerEvent(AddListenerEvent.EVENT, this, false));  	  }  	  game_piece.gotoAndPlay(frame);  	}	  	    public function payArmy() {      var total = 0;      units().forEach(function(unit) { total += unit.upkeep() });      return total*-1;    }    //-------------------------- Piece Movement    public override function stopWalk(sq) {      game_piece.gotoAndPlay('stand');      changed(true);      square(sq);      attr['moves']--;      dispatchEvent(new AddListenerEvent(AddListenerEvent.EVENT, this, true));    }  }}